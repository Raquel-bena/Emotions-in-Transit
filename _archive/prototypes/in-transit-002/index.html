<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emotions in Transit - Skin Deep Adaptation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: 'Arial', sans-serif;
            color: white;
        }
        
        canvas {
            display: block;
        }
        
        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            transition: all 0.3s ease;
        }
        
        .info-panel:hover {
            background: rgba(0, 0, 0, 0.9);
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .emotion-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .emotion-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .emotion-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .emotion-btn.active {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }
        
        .emotion-joy { background: linear-gradient(45deg, #ffd166, #ff9e6d); }
        .emotion-sadness { background: linear-gradient(45deg, #6c9bcf, #3a6ea5); }
        .emotion-anger { background: linear-gradient(45deg, #ef476f, #d7263d); }
        .emotion-calm { background: linear-gradient(45deg, #06d6a0, #118ab2); }
        .emotion-anxiety { background: linear-gradient(45deg, #ff9e6d, #ef476f); }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease;
        }
        
        .loading-bar {
            width: 300px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <h1>EMOTIONS IN TRANSIT</h1>
        <p style="margin-top: 10px; color: #aaa; font-size: 1.1em;">Loading emotional journey...</p>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>
    
    <div class="info-panel">
        <h1>Emotions in Transit</h1>
        <p style="margin-bottom: 10px; color: #ccc;">Two bodies traveling through emotional landscapes - inspired by Skin Deep project</p>
        <div class="emotion-controls">
            <button class="emotion-btn emotion-joy" data-emotion="joy">Joy</button>
            <button class="emotion-btn emotion-sadness" data-emotion="sadness">Sadness</button>
            <button class="emotion-btn emotion-anger" data-emotion="anger">Anger</button>
            <button class="emotion-btn emotion-calm" data-emotion="calm">Calm</button>
            <button class="emotion-btn emotion-anxiety" data-emotion="anxiety">Anxiety</button>
            <button class="emotion-btn" data-emotion="mixed">Mixed Emotions</button>
        </div>
    </div>
    
    <div class="particles" id="particles"></div>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        class EmotionsInTransit {
            constructor() {
                this.container = document.body;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.clock = new THREE.Clock();
                this.emotionState = {
                    current: 'mixed',
                    intensity: 0.8,
                    transition: 0
                };
                this.bodies = [];
                this.particles = [];
                this.init();
            }
            
            async init() {
                this.setupRenderer();
                this.setupCamera();
                this.setupLighting();
                this.createBodies();
                this.createParticles();
                this.setupControls();
                this.setupPostProcessing();
                this.setupEventListeners();
                this.animate();
                this.hideLoadingScreen();
            }
            
            setupRenderer() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                this.container.appendChild(this.renderer.domElement);
            }
            
            setupCamera() {
                this.camera.position.z = 5;
                this.camera.position.y = 1.5;
            }
            
            setupLighting() {
                // Ambient light for base illumination
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
                
                // Main directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                // Emotional rim lights
                this.emotionalLights = {
                    joy: new THREE.PointLight(0xffd166, 2, 10),
                    sadness: new THREE.PointLight(0x6c9bcf, 2, 10),
                    anger: new THREE.PointLight(0xef476f, 2, 10),
                    calm: new THREE.PointLight(0x06d6a0, 2, 10),
                    anxiety: new THREE.PointLight(0xff9e6d, 2, 10)
                };
                
                Object.values(this.emotionalLights).forEach(light => {
                    light.position.set(0, 2, 0);
                    this.scene.add(light);
                });
            }
            
            createBodies() {
                // Create two abstract human forms
                const bodyGroup1 = new THREE.Group();
                const bodyGroup2 = new THREE.Group();
                
                // Body 1 - More geometric, angular
                this.createAbstractHuman(bodyGroup1, {
                    color: 0xff6b6b,
                    position: { x: -1.5, y: 0, z: 0 },
                    scale: 0.8,
                    angular: true
                });
                
                // Body 2 - More organic, smooth
                this.createAbstractHuman(bodyGroup2, {
                    color: 0x4ecdc4,
                    position: { x: 1.5, y: 0, z: 0 },
                    scale: 0.8,
                    angular: false
                });
                
                this.scene.add(bodyGroup1);
                this.scene.add(bodyGroup2);
                
                this.bodies = [bodyGroup1, bodyGroup2];
            }
            
            createAbstractHuman(group, config) {
                const { color, position, scale, angular } = config;
                
                // Torso
                const torsoGeometry = angular ? 
                    new THREE.BoxGeometry(0.8, 1.2, 0.5) : 
                    new THREE.CapsuleGeometry(0.4, 0.8, 4, 8);
                const torsoMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.9,
                    emissive: color,
                    emissiveIntensity: 0.3
                });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 0.6;
                group.add(torso);
                
                // Head
                const headGeometry = angular ? 
                    new THREE.DodecahedronGeometry(0.35, 0) : 
                    new THREE.SphereGeometry(0.35, 32, 32);
                const headMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.95,
                    emissive: color,
                    emissiveIntensity: 0.4
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.4;
                group.add(head);
                
                // Arms
                const armGeometry = new THREE.CapsuleGeometry(0.1, 0.7, 4, 8);
                const armMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });
                
                // Left arm
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.6, 0.8, 0);
                leftArm.rotation.z = -0.3;
                group.add(leftArm);
                
                // Right arm
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.6, 0.8, 0);
                rightArm.rotation.z = 0.3;
                group.add(rightArm);
                
                // Legs
                const legGeometry = new THREE.CapsuleGeometry(0.15, 0.9, 4, 8);
                const legMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.85
                });
                
                // Left leg
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.3, -0.5, 0);
                group.add(leftLeg);
                
                // Right leg
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.3, -0.5, 0);
                group.add(rightLeg);
                
                // Base platform
                const baseGeometry = new THREE.CylinderGeometry(0.8, 1.0, 0.1, 32);
                const baseMaterial = new THREE.MeshPhongMaterial({
                    color: 0x2c3e50,
                    transparent: true,
                    opacity: 0.6
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = -0.9;
                group.add(base);
                
                // Set position and scale
                group.position.set(position.x, position.y, position.z);
                group.scale.set(scale, scale, scale);
                
                // Store references for animation
                group.userData = {
                    originalPosition: { ...position },
                    emotionalMorph: 0,
                    parts: {
                        torso,
                        head,
                        leftArm,
                        rightArm,
                        leftLeg,
                        rightLeg
                    }
                };
            }
            
            createParticles() {
                const particleCount = 200;
                const particleGroup = new THREE.Group();
                
                for (let i = 0; i < particleCount; i++) {
                    const size = Math.random() * 0.1 + 0.05;
                    const geometry = new THREE.SphereGeometry(size, 8, 8);
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: this.getEmotionColor(this.emotionState.current),
                        transparent: true,
                        opacity: Math.random() * 0.6 + 0.2,
                        emissive: this.getEmotionColor(this.emotionState.current),
                        emissiveIntensity: 0.5
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    
                    // Random position in a sphere around the bodies
                    const radius = 3 + Math.random() * 2;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    particle.position.x = Math.sin(phi) * Math.cos(theta) * radius;
                    particle.position.y = Math.cos(phi) * radius;
                    particle.position.z = Math.sin(phi) * Math.sin(theta) * radius;
                    
                    particle.userData = {
                        basePosition: new THREE.Vector3().copy(particle.position),
                        speed: Math.random() * 0.02 + 0.01,
                        size: size,
                        life: Math.random() * 100
                    };
                    
                    particleGroup.add(particle);
                    this.particles.push(particle);
                }
                
                this.scene.add(particleGroup);
            }
            
            getEmotionColor(emotion) {
                const colors = {
                    joy: 0xffd166,
                    sadness: 0x6c9bcf,
                    anger: 0xef476f,
                    calm: 0x06d6a0,
                    anxiety: 0xff9e6d,
                    mixed: 0x9d4edd
                };
                return colors[emotion] || 0x4ecdc4;
            }
            
            setupControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.maxPolarAngle = Math.PI * 0.45;
                this.controls.minDistance = 3;
                this.controls.maxDistance = 10;
            }
            
            setupPostProcessing() {
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5,
                    0.4,
                    0.85
                );
                bloomPass.threshold = 0.1;
                bloomPass.strength = 1.2;
                bloomPass.radius = 0.5;
                this.composer.addPass(bloomPass);
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Emotion buttons
                document.querySelectorAll('.emotion-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const emotion = e.currentTarget.dataset.emotion;
                        this.changeEmotion(emotion);
                        
                        // Update UI
                        document.querySelectorAll('.emotion-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        e.currentTarget.classList.add('active');
                    });
                });
                
                // Start with mixed emotions active
                document.querySelector('[data-emotion="mixed"]').classList.add('active');
            }
            
            changeEmotion(emotion) {
                this.emotionState.transition = 0;
                this.emotionState.targetEmotion = emotion;
                const newColor = this.getEmotionColor(emotion);
                
                // Update lights
                Object.values(this.emotionalLights).forEach(light => {
                    light.intensity = 0;
                });
                
                if (this.emotionalLights[emotion]) {
                    this.emotionalLights[emotion].intensity = 2;
                    this.emotionalLights[emotion].position.set(
                        Math.sin(Date.now() * 0.001) * 3,
                        2 + Math.sin(Date.now() * 0.002) * 0.5,
                        Math.cos(Date.now() * 0.001) * 3
                    );
                }
                
                // Update particles
                this.particles.forEach(particle => {
                    const color = new THREE.Color(newColor);
                    particle.material.color.set(color);
                    particle.material.emissive.set(color);
                });
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }
            
            animate() {
                const delta = this.clock.getDelta();
                const time = this.clock.getElapsedTime();
                
                // Update emotion transition
                if (this.emotionState.current !== this.emotionState.targetEmotion) {
                    this.emotionState.transition += delta * 0.5;
                    if (this.emotionState.transition >= 1) {
                        this.emotionState.current = this.emotionState.targetEmotion;
                        this.emotionState.transition = 1;
                    }
                }
                
                // Animate bodies
                this.bodies.forEach((body, index) => {
                    const t = time + index * 0.5;
                    
                    // Floating animation
                    body.position.y = body.userData.originalPosition.y + Math.sin(t * 0.5) * 0.1;
                    
                    // Gentle rotation
                    body.rotation.y = Math.sin(t * 0.3) * 0.1;
                    
                    // Emotional morphing
                    Object.values(body.userData.parts).forEach(part => {
                        const scale = 1 + Math.sin(t * 2 + index) * 0.1 * this.emotionState.intensity;
                        part.scale.set(scale, scale, scale);
                    });
                    
                    // Update material colors based on emotion
                    const emotionColor = this.getEmotionColor(this.emotionState.current);
                    const color = new THREE.Color(emotionColor);
                    
                    Object.values(body.userData.parts).forEach(part => {
                        part.material.color.set(color);
                        part.material.emissive.set(color);
                    });
                });
                
                // Animate particles
                this.particles.forEach(particle => {
                    const t = time * particle.userData.speed;
                    const basePos = particle.userData.basePosition;
                    
                    // Orbit around center
                    particle.position.x = basePos.x + Math.sin(t) * 0.5;
                    particle.position.z = basePos.z + Math.cos(t) * 0.5;
                    
                    // Bob up and down
                    particle.position.y = basePos.y + Math.sin(t * 0.7) * 0.3;
                    
                    // Pulsate size
                    const pulse = 1 + Math.sin(t * 3) * 0.2;
                    particle.scale.set(pulse, pulse, pulse);
                    
                    // Update particle life
                    particle.userData.life -= delta * 0.1;
                    if (particle.userData.life <= 0) {
                        particle.userData.life = 100;
                        particle.position.set(
                            (Math.random() - 0.5) * 6,
                            (Math.random() - 0.5) * 4,
                            (Math.random() - 0.5) * 6
                        );
                    }
                });
                
                // Animate lights
                Object.values(this.emotionalLights).forEach((light, index) => {
                    if (light.intensity > 0) {
                        light.position.x = Math.sin(time * 0.5 + index) * 3;
                        light.position.z = Math.cos(time * 0.5 + index) * 3;
                    }
                });
                
                // Update controls
                this.controls.update();
                
                // Render
                this.composer.render();
                
                requestAnimationFrame(() => this.animate());
            }
            
            hideLoadingScreen() {
                const loadingScreen = document.getElementById('loadingScreen');
                const loadingProgress = document.getElementById('loadingProgress');
                
                let progress = 0;
                const interval = setInterval(() => {
                    progress += Math.random() * 15;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(interval);
                        setTimeout(() => {
                            loadingScreen.style.opacity = '0';
                            setTimeout(() => {
                                loadingScreen.style.display = 'none';
                            }, 1000);
                        }, 500);
                    }
                    loadingProgress.style.width = `${progress}%`;
                }, 100);
            }
        }
        
        // Inicializar la aplicación cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', () => {
            new EmotionsInTransit();
        });
    </script>
</body>
</html>